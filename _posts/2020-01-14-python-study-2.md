---
title: "[Python] Python Numpy(넘파이)"
layout: post
date: 2020-01-14 20:38
image: 
headerImage: false
tag:
- python
- numpy
- study
category: blog
author: Hoojeong Kim
description: python study
---
# __Python Numpy 기초 정리__

* 수업을 들으며 배운 내용을 정리한 포스트 입니다.
* 해당 실습은 *Jupyter notebook*을 통해 진행되었습니다.

<br>

## __numpy__
 * ### 대부분의 python 데이터는 numpy 데이터로 처리된다.
<br>


```python
# np 라는 이름으로 사용한다(관례)

import numpy as np
```


```python
# 위에서 생성한 list를 사용해 array 정의

np_array = np.array(simple_array)
```


```python
np_array
```

    >  array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
                17, 18, 19])




```python
# array의 크기를 확인

np_array.shape
```

    >  (20,)




```python
# array의 타입 확인 (?)
print(type(np_array))

# array의 데이터 타입 확인
np_array.dtype
```

    >  <class 'numpy.ndarray'>
    >  dtype('int32')




```python
# 1차원 array
arr1 = np.array([1,2,3])
print('1차원\n',arr1, '\n\n')

# 2차원 array
arr2 = np.array([[1,2,3],[1,2,3]])
print('2차원\n',arr2,'\n\n')

# 3차원 array
arr3 = np.array([[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]],[[1,2,3],[1,2,3]]])
print('3차원 \n',arr3)
```

    >  1차원
        [1 2 3] 
    
    
    >  2차원
        [[1 2 3]
        [1 2 3]] 
    
    
    >  3차원 
        [[[1 2 3]
         [1 2 3]]
    
        [[1 2 3]
         [1 2 3]]
    
        [[1 2 3]
         [1 2 3]]]
  
<br>

  * ### __numpy 정의 함수__  
    * np.zeros(), np.ones(), np.arange()

<br>

```python
# np.zeors() : 인자로 받은 크기만큼, 모든 요소가 0인 array 생성

np.zeros(5)
```

    >  array([0., 0., 0., 0., 0.])




```python
np.zeros((3,5))
```

    >  array([[0., 0., 0., 0., 0.],
              [0., 0., 0., 0., 0.],
              [0., 0., 0., 0., 0.]])




```python
# np.ones() : 인자로 받은 크기만큼, 모든 요소가 1인 array 생성

np.ones(10)
```

    >  array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])




```python
np.ones((3,5))
```

    >  array([[1., 1., 1., 1., 1.],
              [1., 1., 1., 1., 1.],
              [1., 1., 1., 1., 1.]])




```python
# np.arange() : 인자로 받은 크기만큼 1씩 증가하는 array 생성
# 하나의 인자 -> 0 ~ (인자 - 1) / 두 개의 인자 -> 인자1 ~ (인자2 - 1)

np.arange(10)
```
    >  array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.arange(3,5)
```

    >  array([3, 4])

<br>

  * ### __Array 연산__  
    * 기본적으로 array끼리 크기가 동일해야 한다.

<br>

```python
x = np.array(range(1,4))
```


```python
x
```

    >  array([1, 2, 3])




```python
y = np.array(range(5,8))
```


```python
y
```

    >  array([5, 6, 7])




```python
x+y
```

    >  array([ 6,  8, 10])




```python
x*y
```

    >  array([ 5, 12, 21])




```python
x*2*y
```

    >  array([10, 24, 42])


<br>

* ### __Array 브로드캐스팅(Broadcasting)__  
  * 크기가 다른 array의 연산을 제공
  * array + 스칼라 값(상수)인 경우
  * 차원이 다르지만 행/열의 개수가 같은 경우
    * 이때 열/행의 개수는 1이어야 확장이 가능 

<br>

```python
ary1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
print(ary1,'\n')

ary2 = np.array([[4],[6],[8]])
print(ary2,'\n')

print(ary1+ary2)
```

    >  [[ 1  2  3  4]
        [ 5  6  7  8]
        [ 9 10 11 12]] 
    
    >  [[4]
        [6]
        [8]] 
    
    >  [[ 5  6  7  8]
        [11 12 13 14]
        [17 18 19 20]]
    
<br>

* ### __Array 인덱싱__  
  * 1차원

<br>

```python
# 1차원 배열 생성
arr1 = np.arange(10)

# array의 1번째 원소
print(arr1[1])

# 1번째부터 5번째 원소
print(arr1[1:5])

# 모든 원소
print(arr1[:])
```

    >  1
    >  [1 2 3 4]
    >  [0 1 2 3 4 5 6 7 8 9]
    
<br>

* ### 1차원이 아닌 경우

<br>

```python
# 2차원 배열 생성
arr2 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])

# 1차원이 아닌 경우, 차원의 개수만큼 인자를 입력해야 함
print(arr2[0,0])

# 2행의 3번째 원소
print(arr2[2,3])

# 2행의 모든 원소
print(arr2[2,:])

# 모든 행의 3번째 원소
print(arr2[:,3])
```

    >  1
    >  12
    >  [ 9 10 11 12]
    >  [ 4  8 12]
    
<br>

* ### __Array Boolean 인덱싱(마스크)__  
  * boolean 인덱싱을 통해, 원하는 원소만을 보여줄 수 있음

<br>

```python
names = np.array(['Kim', 'Kim', 'Hoo','Jeong','woman','Kim','22','Kim'])
print(names,'\n')

# np.random 함수를 사용해, 난수 생성
data = np.random.rand(8,4)
print(data)
```

    >  ['Kim' 'Kim' 'Hoo' 'Jeong' 'woman' 'Kim' '22' 'Kim'] 
    
    >  [[0.6186156  0.39221665 0.04080922 0.11753323]
        [0.83000709 0.4668394  0.6490857  0.70440535]
        [0.62749346 0.3263693  0.83117066 0.41961748]
        [0.44552161 0.74228304 0.18339153 0.33337113]
        [0.81040857 0.56784962 0.98615035 0.00574617]
        [0.39602452 0.55969188 0.16540082 0.58794943]
        [0.74925881 0.12681063 0.46470231 0.96157132]
        [0.50175472 0.24763934 0.2264423  0.98064603]]
    
<br>

- names의 각 원소가 data의 각 행과 연결된다고 가정
- names의 원소가 'Kim'인 행의 data만 보고싶을 경우, 다음과 같이 마스크 사용

<br>

```python
# 원소가 'Kim'일 때, 이에 대한 mask 생성
names_mask = (names == 'Kim')
print(names_mask,'\n')

# 마스크가 해당하는 행의 모든 원소
print(data[names_mask, :])
```

    >  [ True  True False False False  True False  True] 
    
    >  [[0.6186156  0.39221665 0.04080922 0.11753323]
        [0.83000709 0.4668394  0.6490857  0.70440535]
        [0.39602452 0.55969188 0.16540082 0.58794943]
        [0.50175472 0.24763934 0.2264423  0.98064603]]
    


```python
# 원소가 'Kim'인 행의 데이터만 출력
print(data[names == 'Kim'],'\n')

# 논리 연산을 사용해, 원소가 'Kim' 또는 'Hoo'인 행의 데이터 출력
print(data[(names == 'Kim') | (names == 'Hoo'), :])
```

    >  [[0.6186156  0.39221665 0.04080922 0.11753323]
        [0.83000709 0.4668394  0.6490857  0.70440535]
        [0.39602452 0.55969188 0.16540082 0.58794943]
        [0.50175472 0.24763934 0.2264423  0.98064603]] 
    
    >  [[0.6186156  0.39221665 0.04080922 0.11753323]
        [0.83000709 0.4668394  0.6490857  0.70440535]
        [0.62749346 0.3263693  0.83117066 0.41961748]
        [0.39602452 0.55969188 0.16540082 0.58794943]
        [0.50175472 0.24763934 0.2264423  0.98064603]]
    
<br>

* ### __mask 활용__

<br>

```python
# 마스크 생성
# data array에서 모든 행의 0번째 열중, 0.5보다 작은 원소의 boolean 값

mask = data[:,0]<0.5
mask
```

    >  array([False, False, False,  True, False,  True, False, False])




```python
# 위에서 생성한 마스크를 사용해, 0번째 열 중에서 값이 0.5보다 작은 행 출력
data[mask, :]
```

    >  array([[0.44552161, 0.74228304, 0.18339153, 0.33337113],
              [0.39602452, 0.55969188, 0.16540082, 0.58794943]])




```python
# 0번째 열 중에서 0.5보다 작은 행의 2, 3번째 열의 값을 -1로 변경
data[mask, 2:4] = -1
data
```

    >  array([[ 0.6186156 ,  0.39221665,  0.04080922,  0.11753323],
              [ 0.83000709,  0.4668394 ,  0.6490857 ,  0.70440535],
              [ 0.62749346,  0.3263693 ,  0.83117066,  0.41961748],
              [ 0.44552161,  0.74228304, -1.        , -1.        ],
              [ 0.81040857,  0.56784962,  0.98615035,  0.00574617],
              [ 0.39602452,  0.55969188, -1.        , -1.        ],
              [ 0.74925881,  0.12681063,  0.46470231,  0.96157132],
              [ 0.50175472,  0.24763934,  0.2264423 ,  0.98064603]])


<br>

* ### __Array 적용 함수__

<br>


```python
# 난수
f_arr = np.random.rand(5,3)

# 각 성분의 절대값
print(np.abs(f_arr), '\n')

# 각 성분의 제곱근 (제곱은 square)
print(np.sqrt(f_arr), '\n')

# 각 성분을 소수 첫 번째 자리에서 올림 (반대는 floor)
print(np.ceil(f_arr))
```

    >  [[0.13662286 0.86748233 0.670893  ]
        [0.96363495 0.57334322 0.87951414]
        [0.57169924 0.93055328 0.46997525]
        [0.82231103 0.93210572 0.74877588]
        [0.7818933  0.09953493 0.77589589]] 
       
    >  [[0.3696253  0.93138731 0.81908058]
        [0.9816491  0.75719431 0.93782415]
        [0.75610796 0.9646519  0.68554741]
        [0.90681367 0.96545622 0.86531837]
        [0.88424731 0.31549157 0.88084953]] 
    
    >  [[1. 1. 1.]
        [1. 1. 1.]
        [1. 1. 1.]
        [1. 1. 1.]
       [1. 1. 1.]]
    
<br>

* ### __차원 변경__
  - reshape(n,m) : row(행) n, column(열) m의 차원으로 변경
  - reshape(-1, m) : column m 차원으로 row를 자동으로 변경
  - reshape(-1,) : 1차원 으로 변경

<br>

```python
np_4_5 = np_array.reshape(4,5)
```


```python
np_4_5
```

    >  array([[ 0,  1,  2,  3,  4],
              [ 5,  6,  7,  8,  9],
              [10, 11, 12, 13, 14],
              [15, 16, 17, 18, 19]])




```python
np_1_20 = np_4_5.reshape(1, 20)
```


```python
np_1_20
```

    >  array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
               16, 17, 18, 19]])




```python
np_1 = np_1_20.reshape(-1,)
```


```python
np_1
```

    >  array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
              17, 18, 19])

